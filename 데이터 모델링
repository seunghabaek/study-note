## 데이터 모델링
- 개념적 구조를 정하는 것 -> 논리적 모델링

- 데이터베이스 구축에 필요한 걸 정하는 것 -> 물리적 모델링


# 데이터 모델
- Entity(개체) : 저장하고 싶은 데이터의 대상(ex. 학생, 수업, 교수)

- Attribute(속성) : Entity에 대해서 저장하려는 내용.(Table에서 column)

- Ralationship(관계) : Entity들 사이의 연결점

- Constraint(제약 조건) : 데이터에 대한 규칙

- 데이터 모델링의 목적 
	1. 저장하고자 하는 데이터에서 Entity, Attribute, Relationship, Constraint 파악

	2. 데이터베이스를 구축할 때 기반이 될 모델 만들기.


# Relational Model
- 데이터를 relation, 즉 테이블로 정리해서 표현한 모델.

- 데이터간 관계는 f.k를 통해서 만들 수 있다.

- relation : 테이블, relationship : 테이블 사이 맺어지는 관계


# Entity Relationship Model(ERM)
- Relational Model과는 달리 데이터를 table의 형태로 표현하지는 않음.

- 개체와 관계를 중심으로 모델링.

- 관계의 특징에 따라 모델링하는 방법이 바뀜.


## 논리적 모델링
- 비즈니스 룰 : 특정 조직이 운영되기 위해 따라야 하는 정책, 절차, 원칙들에 대한 간단명료한 설명.
	1. 모든 명사는 entity 후보다
	2. 모든 동사는 relationship 후보다
	3. 하나의 값으로 표현할 수 있는 명사는 attribute 후보다
		-> 3의 예외 : 여러 값을 가질 수 있다면 entity 후보다


# 카디널리티(Cardinality)
- Entity type A와 B 사이에서 A Entity 한 개가 B Entity 몇 개와 연결될 수 있고, B Entity 한 개가 A Entity 몇 개와 연결될 수 있는지

- 일대일, 일대다, 다대다 -> 어떤 관계가 있는지에 따라 모델링이 바뀐다.
	-> 다대다 관계에 있는 두 Entity는, 새로운 Entity + 두 개의 일대다 관계로 모델링한다.
	-> 다대다 관계에서는 동사도 entity가 될 수 있다.
	

## 정규화
- 이상현상(anomaly)
	1. 데이터베이스에서 삽입, 업데이트, 삭제를 제대로 할 수 없게 되는 경우
	2. 데이터 모델링을 제대로 하지 않았기 때문에 발생

- 정규화(Normalization)
	1. 데이터베이스에서 삽입, 업데이트, 삭제 이상을 없앨 수 있다.
	2. 새로운 종류의 데이터를 추가할 때 테이블 구조 수정을 많이 하지 않아도 된다.
	3. 데이터베이스 구조를 단순화해서 사용자가 더 쉽게 이해할 수 있다.
	4. 정규화는 데이터 모델을 만들고, 데이터베이스에 구현하기 전에 적용하는 것이 좋다.

	- 제 1정규형(1NF) : 나눌 수 없는 단일 값
		1. 한 컬럼에 같은 종류의 값을 여러 개 저장하고 있을 때(ex. 전화번호)
			-> 이때는 해당 컬럼을 하나의 테이블로 분리해서 모델링(ex. 전화번호 테이블)

		2. 한 컬럼에 서로 다른 종류의 값을 여러 개 저장하고 있을 때(ex. 이름)
			-> 이때는 한 컬럼을 여러 개로 분리해서 모델링(ex. 성/이름 따로)

	- Candidate Key : 하나의 로우를 특정 지을 수 있는 attribute들의 최소 집합.
		- Prime attribute : Candidate Key에 속한 attribute들
		- Non prime attribute : Candidate Key가 아닌 attribute들

	- 제 2정규형(2NF)
		1. 1NF에 부합해야함
		(테이블 안 모든 값이 나눌 수 없는 단일 값이어야 함.)

		2. 테이블에 candidate key의 일부분에 대해서만 함수 종속성이 있는 non-prime attribute가 없어야 함.

		-> 각각 관련있는 테이블로 옮겨주고, 테이블이 없다면 따로 별도의 테이블을 생성해서 관리.

	- 제 3정규형(3NF)
		1. 2NF에 부합해야 함
		(테이블 안 모든 값은 나눌 수 없는 단일값, 일부분에 대한 종속성x)

		2. 테이블 안에 있는 모든 attribute들은 오직 primary key에 대해서만 함수 종속성이 있어야 함.

		-> 관련이 있는 테이블로 옮겨준다.


## 물리적 모델링
- 네이밍(규칙)
	1. 단/복수 선택 : 컬럼 이름은 보통 단수.
	2. 대문자/띄어쓰기 정하기
	3. 줄임말 정하기

	-> 어떤 규칙을 정하는지보다 정해진 규칙을 잘 따르는 게 중요하다.

- 데이터 타입
	1. 각 컬럼이 어떤 데이터를 저장하는지에 대한 내용
	2. 데이터베이스의 가장 기본적인 제약 사항
	(데이터의 정확성을 지켜주는 역할)

	- 정수형 타입
		1. TINYINT : 가장 작은 범위(0~255/ -128~127) 
		2. SMALLINT : 조금 더 큰 범위(0~65535/ -32768~32767) 
		3. MEDIUMINT : 더 넓은 범위(0~16777215/ -8388608~8388607)
		4. INT
		5. BIGINT

	- 실수형 타입
		1. DECIMAL
		2. FLOAT
		3. DOUBLE

	- 데이터 타입을 잘 정해야 되는 이유
		1. 데이터 정확성을 지키기 위해
		2. 데이터베이스 연산/함수들을 제대로 활용하기 위해서
		3. 데이터베이스 용량을 최적화하기 위해서(같은 정보를 저장하되, 가장 적게 쓰는 것이 좋다.)

- 인덱스 : 원하는 값을 찾기 위해 특정 컬럼에 정렬해서 놓은 값
	- 선형 탐색 : 앞에서부터 차례차례 원하는 값이 나올 때까지 검색하는 방식.

	- 이진 탐색 : 정렬된 데이터를 검색할 때 중간값을 기준으로 검색하는 방식.


	- Clustered 인덱스 : 테이블 자체를 특정 순서로 저장하는 인덱스
		- 조회 속도가 굉장히 빠름.
		- 인덱스를 하나밖에 못 만듬.
		- 언어 사전과 비슷한 개념.

	- Non-Clustered 인덱스 : 테이블 자체는 그대로 놔두고 다른 곳에 순서를 저장하는 인덱스.
		- 인덱스를 모든 컬럼에 대해서 만들 수 있음.
		- 따로 테이블에 저장해놓기 때문에 Clustered 인덱스보다는 조금 느림.
		- 일반 책의 색인, 또는 인덱스와 비슷한 개념.

	- 인덱스 추가 기본 원칙
		1. 모든 primary key에 대해서 인덱스를 만들어 줌.
		2. 모든 foreign key에 대해서 인덱스를 만들어 줌.
		3. 특정 조회 쿼리가 너무 느려지거나, 느려질 게 확실한 경우 조회에 사용되는 컬럼들에 대해서 인덱스를 만들어 줌.






